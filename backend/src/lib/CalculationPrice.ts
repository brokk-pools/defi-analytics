import { db } from './db.js';

// Cache simples para pre√ßos (TTL: 5 minutos)
const priceCache = new Map<string, { price: number; timestamp: number }>();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutos em millisegundos

interface CoinGeckoCurrentPrice {
  [coingeckoId: string]: {
    usd: number;
  };
}

interface CoinGeckoHistoricalPrice {
  id: string;
  symbol: string;
  name: string;
  market_data: {
    current_price: {
      usd: number;
    };
  };
}

/**
 * Busca o ID do CoinGecko para um token Solana na tabela token_metadata
 */
async function getCoinGeckoId(tokenAddress: string): Promise<string | null> {
  try {
    const result = await db.query(
      'SELECT coingecko_id FROM token_metadata WHERE token = $1',
      [tokenAddress]
    );
    
    if (result.rows.length === 0) {
      console.warn(`‚ö†Ô∏è Token ${tokenAddress} n√£o encontrado na tabela token_metadata`);
      return null;
    }
    
    return result.rows[0].coingecko_id;
  } catch (error) {
    console.error(`‚ùå Erro ao buscar CoinGecko ID para ${tokenAddress}:`, error);
    return null;
  }
}

/**
 * 1) Fun√ß√£o para obter pre√ßo atual de um token em USD via CoinGecko
 * @param tokenAddress - Endere√ßo do token Solana
 * @returns Pre√ßo atual em USD ou 0 se n√£o encontrado
 */
export async function getCurrentPrice(tokenAddress: string): Promise<number> {
  try {
    // Verificar cache primeiro
    const cached = priceCache.get(tokenAddress);
    if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
      console.log(`üì¶ Pre√ßo em cache para ${tokenAddress}: $${cached.price}`);
      return cached.price;
    }
    
    // Buscar o ID do CoinGecko na tabela token_metadata
    const coingeckoId = await getCoinGeckoId(tokenAddress);
    if (!coingeckoId) {
      return 0;
    }
    
    // Buscar pre√ßo atual na API do CoinGecko
    const response = await fetch(
      `https://api.coingecko.com/api/v3/simple/price?ids=${coingeckoId}&vs_currencies=usd`
    );
    
    if (!response.ok) {
      if (response.status === 429) {
        console.warn(`‚ö†Ô∏è Rate limit excedido na CoinGecko. Usando cache se dispon√≠vel.`);
        // Se temos cache antigo, usar ele mesmo expirado
        if (cached) {
          console.log(`üì¶ Usando cache expirado para ${tokenAddress}: $${cached.price}`);
          return cached.price;
        }
      }
      throw new Error(`Erro na API do CoinGecko: ${response.status} ${response.statusText}`);
    }
    
    const data: CoinGeckoCurrentPrice = await response.json();
    
    if (!data[coingeckoId] || !data[coingeckoId].usd) {
      console.warn(`‚ö†Ô∏è Pre√ßo n√£o encontrado para ${coingeckoId} na API do CoinGecko`);
      return 0;
    }
    
    const price = data[coingeckoId].usd;
    
    // Salvar no cache
    priceCache.set(tokenAddress, { price, timestamp: Date.now() });
    
    console.log(`‚úÖ Pre√ßo atual ${coingeckoId}: $${price} (salvo no cache)`);
    return price;
    
  } catch (error) {
    console.error(`‚ùå Erro ao buscar pre√ßo atual para ${tokenAddress}:`, error);
    
    // Se temos cache, usar mesmo que expirado
    const cached = priceCache.get(tokenAddress);
    if (cached) {
      console.log(`üì¶ Usando cache de fallback para ${tokenAddress}: $${cached.price}`);
      return cached.price;
    }
    
    return 0;
  }
}

/**
 * 2) Fun√ß√£o para obter pre√ßo hist√≥rico de um token em USD via CoinGecko
 * @param tokenAddress - Endere√ßo do token Solana
 * @param date - Data no formato DD-MM-YYYY (ex: "01-10-2025")
 * @returns Pre√ßo hist√≥rico em USD ou 0 se n√£o encontrado
 */
export async function getHistoricalPrice(tokenAddress: string, date: string): Promise<number> {
  try {
    // Verificar se a data fornecida √© igual √† data atual
    const currentDate = new Date();
    const currentDay = String(currentDate.getDate()).padStart(2, '0');
    const currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');
    const currentYear = currentDate.getFullYear();
    const currentDateString = `${currentDay}-${currentMonth}-${currentYear}`;
    
    if (date === currentDateString) {
      console.log(`üìÖ Data fornecida (${date}) √© igual √† data atual, usando getCurrentPrice`);
      return await getCurrentPrice(tokenAddress);
    }
    
    // Verificar cache para pre√ßos hist√≥ricos (chave: tokenAddress_date)
    const cacheKey = `${tokenAddress}_${date}`;
    const cached = priceCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp) < CACHE_TTL) {
      console.log(`üì¶ Pre√ßo hist√≥rico em cache para ${tokenAddress} em ${date}: $${cached.price}`);
      return cached.price;
    }
    
    // Buscar o ID do CoinGecko na tabela token_metadata
    const coingeckoId = await getCoinGeckoId(tokenAddress);
    if (!coingeckoId) {
      return 0;
    }
    
    // Buscar pre√ßo hist√≥rico na API do CoinGecko
    const response = await fetch(
      `https://api.coingecko.com/api/v3/coins/${coingeckoId}/history?date=${date}`
    );
    
    if (!response.ok) {
      if (response.status === 429) {
        console.warn(`‚ö†Ô∏è Rate limit excedido na CoinGecko para pre√ßo hist√≥rico. Usando cache se dispon√≠vel.`);
        // Se temos cache antigo, usar ele mesmo expirado
        if (cached) {
          console.log(`üì¶ Usando cache hist√≥rico expirado para ${tokenAddress} em ${date}: $${cached.price}`);
          return cached.price;
        }
      }
      throw new Error(`Erro na API do CoinGecko: ${response.status} ${response.statusText}`);
    }
    
    const data: CoinGeckoHistoricalPrice = await response.json();
    
    if (!data.market_data || !data.market_data.current_price || !data.market_data.current_price.usd) {
      console.warn(`‚ö†Ô∏è Pre√ßo hist√≥rico n√£o encontrado para ${coingeckoId} na data ${date}`);
      return 0;
    }
    
    const price = data.market_data.current_price.usd;
    
    // Salvar no cache
    priceCache.set(cacheKey, { price, timestamp: Date.now() });
    
    console.log(`‚úÖ Pre√ßo hist√≥rico ${coingeckoId} em ${date}: $${price} (salvo no cache)`);
    return price;
    
  } catch (error) {
    console.error(`‚ùå Erro ao buscar pre√ßo hist√≥rico para ${tokenAddress} em ${date}:`, error);
    
    // Se temos cache, usar mesmo que expirado
    const cacheKey = `${tokenAddress}_${date}`;
    const cached = priceCache.get(cacheKey);
    if (cached) {
      console.log(`üì¶ Usando cache hist√≥rico de fallback para ${tokenAddress} em ${date}: $${cached.price}`);
      return cached.price;
    }
    
    return 0;
  }
}

/**
 * Fun√ß√£o auxiliar para obter pre√ßo baseado em timestamp
 * Se timestamp for fornecido, busca pre√ßo hist√≥rico, sen√£o busca pre√ßo atual
 */
export async function getPriceUSD(tokenAddress: string, timestamp?: number): Promise<number> {
  if (timestamp) {
    // Converter timestamp para formato DD-MM-YYYY
    const date = new Date(timestamp * 1000);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    const dateString = `${day}-${month}-${year}`;
    
    return await getHistoricalPrice(tokenAddress, dateString);
  } else {
    return await getCurrentPrice(tokenAddress);
  }
}
